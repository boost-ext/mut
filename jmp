// <!--
//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifdef README
// -->
[![Boost Licence](http://img.shields.io/badge/license-boost-blue.svg)](http://www.boost.org/LICENSE_1_0.txt)
[![Version](https://badge.fury.io/gh/qlibs%2Fjmp.svg)](https://github.com/qlibs/jmp/releases)
[![build](https://img.shields.io/badge/build-blue.svg)](https://godbolt.org/z/j5nW57e7W)
[![Try it online](https://img.shields.io/badge/try%20it-online-blue.svg)](https://godbolt.org/z/jjqzY7Wf6)

---------------------------------------

## JMP: Static branch library

> https://en.wikipedia.org/wiki/Branch_(computer_science)

### Use cases

> Performance
> - branch is relatively stable through its life cycle `and/or`
> - branch is expensive to compute and/or require memory access `and/or`
> - branch is hard to predict/learn by the hardware

> Examples: logging, tracing, dispatching, ...

### Features

- Single header (https://raw.githubusercontent.com/qlibs/jmp/main/jmp - for integration see [FAQ](#faq))
- Minimal [API](#api)
- Verifies itself upon include (can be disabled with `-DNTEST` - see [FAQ](#faq))

### Requirements

- C++20 ([clang++15+, g++11+](https://en.cppreference.com/w/cpp/compiler_support)) / [x86-64](https://en.wikipedia.org/wiki/X86-64) / [Linux](https://en.wikipedia.org/wiki/Linux)

---

### Overview

> `static_branch` (https://godbolt.org/z/nx8G7v6zE)

```cpp
/**
 * constexpr minimal overhead static bool changed at run-time via code patching
 */
constexpr jmp::static_branch semi_runtime_branch = false;

/**
 * Note: `fun` can be inline/noinline/constexpr/etc.
 * constexpr void fun();
 * inline void fun();
 * [[gnu::noinline]] void fun()
 * [[gnu::always_inline]] void fun()
 */
void fun() {
  if (semi_runtime_branch) {
    std::puts("taken");
  } else {
    std::puts("not taken");
  }
}

int main() {
  std::ignore = jmp::static_branch::init(); // enables run-time code patching

  fun(); // not taken

  semi_runtime_branch = true;
  fun(); // taken

  semi_runtime_branch = false;
  fun(); // not taken
}
```

```cpp
main: // $CXX -O3
  lea rdi, [rip + .L.str.1]
  nop # code patching (nop->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp1:
  call puts@PLT # not taken

  call semi_runtime_branch.operator=(true)

  lea rdi, [rip + .L.str.1]
  jmp .Ltmp2 # code patching (nop->jmp)
  lea rdi, [rip + .L.str.2]
 .Ltmp2:
  call puts@PLT # taken

  call semi_runtime_branch.operator=(false)

  lea rdi, [rip + .L.str.1]
  nop # code patching (jmp->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp3:
  call puts@PLT # not taken

  xor  eax, eax # return 0
  ret

.L.str.1: .asciz "taken"
.L.str.2: .asciz "not taken"
```

----

### Examples

> `variant` (https://godbolt.org/z/breWs5xfb) | (https://wg21.link/P2996)

```cpp
template<class... Ts>
class variant {
 public:
  template<class T>
  constexpr explicit(false) variant(T&& t) {
    constexpr auto index = [] {
      std::array match{std::is_same_v<Ts, std::remove_cvref_t<T>>...};
      return std::ranges::find(match, true)-match.begin();
    }();
    for (auto& option : options) option = false;
    options[index] = true;
    std::construct_at(&storage_.[:
      nonstatic_data_members_of(^storage)[index+1u] :], std::forward<T>(t)
    );
  }

  template<auto N = 0u, class Fn>
  constexpr auto visit(Fn&& fn) const -> decltype(auto) {
    if constexpr (N < sizeof...(Ts)) {
      if (options[N]) {
        return std::invoke(std::forward<Fn>(fn),
          storage_.[: nonstatic_data_members_of(^storage)[N+1u] :]);
      } else {
        return visit<N + 1u>(std::forward<Fn>(fn));
      }
    }
    std::unreachable();
  }

  // ...

private:
  union storage;
  struct empty{ };
  static_assert(is_type(define_class(^storage, {
    std::meta::data_member_spec(^empty, {.name = "empty"}),
    std::meta::data_member_spec(^Ts)...
  })));
  template<class...> static constexpr auto false_v = false;
  static constexpr std::array options{jmp::static_branch{false_v<Ts>}...};
  storage storage_{.empty={}};
};
```

```cpp
void usage(const variant<bool, int, float>& v) {
  v.visit(overload{
    [](bool)  { std::puts("bool");  },
    [](int)   { std::puts("int");   },
    [](float) { std::puts("float"); },
  });
}

int main() {
  std::ignore = jmp::static_branch::init();

  variant<bool, int, float> v{};

  v = true;
  usage(v);

  v = 42;
  usage(v);

  v = 42.f;
  usage(v);
}
```

```cpp
usage(variant<bool, int, float> const&):
  lea rdi, [rip + .L.str.1]
  nop # code patching (nop->jmp)
  lea rdi, [rip + .L.str.2]
  nop # code patching (jmp->jmp)
  lea rdi, [rip + .L.str.3]
  nop # code patching (jmp->jmp)
  jmp puts

.L.str.1: .asciz  "bool"
.L.str.2: .asciz  "int"
.L.str.3: .asciz  "float"
```

---

### API

```cpp
/**
 * Minimal overhead (via code patching) static bool
 */
class static_branch final {
 public:
  /**
   * Creates empty class (static_assert(sizeof(static_branch) == 1u))
   * @param direction initial branch direction
   * Note: direction should be false by default
   *       for better performance: { false: nop, true: unstatic_branch jmp }
   */
  constexpr explicit(false) static_branch(const auto direction) noexcept;
  constexpr static_branch(const static_branch&) noexcept = delete;
  constexpr static_branch(static_branch&&) noexcept = delete;
  constexpr auto operator=(const static_branch&) noexcept = delete;
  constexpr auto operator=(static_branch&&) noexcept = delete;

  /**
   * Makes required pages writable for code patching
   * Note: Must be called before chaning the branch direction (`branch = true/false`)
   *       Should be called only once per application
   * @param page_size page size (default: sysconf(_SC_PAGESIZE))
   * @param permissions protect permissions (default: PROT_READ | PROT_WRITE | PROT_EXEC)
   * @return 0 if succesful, -1 on error (errno is set to indicate the error)
   */
  [[nodiscard]] static constexpr auto init(const u64 page_size = sysconf(_SC_PAGESIZE),
                                           const u64 permissions = 0b111) noexcept -> int;

  /**
   * Updates branch direction
   * @param direction new branch direction
   */
  constexpr void operator=(const auto direction) const noexcept;

  /**
   * Returns branch direction
   * @return current branch direction
   */
  [[gnu::always_inline]] [[nodiscard]] inline operator bool() const noexcept;
};
```

> Configuration

```cpp
#define JMP 3'0'0 // Current library version (SemVer)
```

---

### FAQ

- How does it work?

  > `jmp` is using technique called code patching - which basically means that the code modifies itself.

  `jmp::static_branch` is based on https://docs.kernel.org/staging/static-keys.html and it requires `asm goto` support (gcc, clang).
  `jmp` currently supports x86-64 Linux, but other platforms can be added using the same technique.

  Example:

    ```cpp
    constexpr jmp::static_branch b = false;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      .byte 15 31 68 0 0 # nop - https://www.felixcloutier.com/x86/nop
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

  which will effectively execute...

    ```cpp
    main:
      nop
      xor eax, eax # return 0
      ret
    ```

  now, if we change the branch direction at run-time...

    ```cpp
    b = true;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      call b.operator=(true); # nop->jmp or jmp->nop

      jmp .LBB1: (nop->jmp - changed in the memory of the program)
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

- How to integrate with CMake/CPM?

    ```
    CPMAddPackage(
      Name jmp
      GITHUB_REPOSITORY qlibs/jmp
      GIT_TAG v3.0.0
    )
    add_library(mp INTERFACE)
    target_include_directories(mp SYSTEM INTERFACE ${mp_SOURCE_DIR})
    add_library(jmp::jmp ALIAS jmp)
    ```

    ```
    target_link_libraries(${PROJECT_NAME} jmp:jmp)
    ```

- Acknowledgments

  > https://docs.kernel.org/staging/static-keys.html, https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html, https://www.agner.org/optimize/instruction_tables.pdf, https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html, https://www.felixcloutier.com/documents/gcc-asm.html, https://www.felixcloutier.com/x86, https://uops.info/table.html, https://arxiv.org/abs/2308.14185, https://arxiv.org/pdf/2011.13127

<!--
#else
#pragma GCC system_header
#ifndef $JMP
#define $JMP 3'0'0 // SemVer

extern "C" int mprotect(void*, __SIZE_TYPE__, int);

namespace jmp::inline v3_0_0 {
using u8  = __UINT8_TYPE__;
using u16 = __UINT16_TYPE__;
using u32 = __UINT32_TYPE__;
using u64 = __UINT64_TYPE__;
using size_t = __SIZE_TYPE__;

namespace utility {
template<class T, size_t N>
struct array {
  T data[N]{};
  [[nodiscard]] constexpr const auto& operator[](size_t I) const { return data[I]; }
  static constexpr auto size() { return N; }
};
template<class T, class... Ts> array(T, Ts...) -> array<T, 1u + sizeof...(Ts)>;
} // utility

namespace detail {
struct entry {
  void *self{};   /// identifier
  void* memory{}; /// code memory (to be patched)
  u64 offset{};   /// jmp offset
};
extern "C" entry __start___jmp [[gnu::section("__jmp")]];
extern "C" entry __stop___jmp [[gnu::section("__jmp")]];
} // detail

#if defined(__x86_64__)
inline namespace x86_64 {
/**
 * Minimal overhead (via code patching) static bool
 */
class static_branch final {
  using uop_t = utility::array<u8, 5u>;
  static constexpr uop_t NOP{0x0f, 0x1f, 0x44, 0x00, 0x00}; /// https://www.felixcloutier.com/x86/nop
  struct [[gnu::packed]] JMP{ u8 op{0xe9}; u32 offset; };   /// https://www.felixcloutier.com/x86/jmp
  static_assert(sizeof(NOP) == sizeof(JMP));

 public:
  /**
   * Creates empty class (static_assert(sizeof(static_branch) == 1u))
   * @param direction initial branch direction (direction: should be false)
   */
  constexpr explicit(false) static_branch(const auto direction) noexcept {
    void failed(); if (direction) failed(); /// direction should be false by default for better performance: { false: nop, true: unstatic_branch jmp }
  }
  constexpr static_branch(const static_branch&) noexcept = delete;
  constexpr static_branch(static_branch&&) noexcept = delete;
  constexpr auto operator=(const static_branch&) noexcept = delete;
  constexpr auto operator=(static_branch&&) noexcept = delete;

  /**
   * Makes required pages writable for code patching
   * Note: Must be called before chaning the branch direction (`branch = true/false`)
   *       Should be called only once per application
   * @param page_size page size (default: sysconf(_SC_PAGESIZE))
   * @param permissions protect permissions (default: PROT_READ | PROT_WRITE | PROT_EXEC)
   * @return 0 if succesful, -1 on error (errno is set to indicate the error)
   */
  [[nodiscard]] static constexpr auto init(const u64 page_size = 4096u, const u64 permissions = 0b111) noexcept -> int {
    for (auto entry = &detail::__start___jmp; entry != &detail::__stop___jmp; ++entry) {
      const auto memory = reinterpret_cast<void*>((u64)entry->memory & ~(page_size - 1u));
      if (const auto error = mprotect(memory, sizeof(uop_t), permissions)) {
        return error;
      }
    }
    return {};
  }

  /**
   * Updates branch direction
   * @param direction new branch direction
   */
  constexpr void operator=(const auto direction) const noexcept {
    JMP jmp{};
    const uop_t* ops[]{&NOP, reinterpret_cast<const uop_t*>(&jmp)};
    for (auto entry = &detail::__start___jmp; entry != &detail::__stop___jmp; ++entry) {
      if (entry->self != this) continue;
      jmp.offset = static_cast<u32>(entry->offset);
      *static_cast<uop_t*>(entry->memory) = *ops[direction];
    }
  }

  /**
   * Returns branch direction
   * @return current branch direction
   */
  [[gnu::always_inline]] [[nodiscard]] inline operator bool() const noexcept {
    asm volatile goto("0:"
      ".byte %c3, %c4, %c5, %c6, %c7 \n"
      ".pushsection __jmp, \"aw\" \n"
      ".balign %c0 \n"
      ".quad %c1, 0b, %l[true_] - (0b + %c2) \n"
      ".popsection \n"
      : : "i"(alignof(u64)),
          "i"(this),
          "i"(sizeof(uop_t)),
          "i"(NOP[0]), "i"(NOP[1]), "i"(NOP[2]), "i"(NOP[3]), "i"(NOP[4])
      : : true_);
    false_: return false;
    true_:  return true;
  }
};
} // namespace x86_64
#endif
} // namespace jmp

#ifndef NTEST
static_assert(([] {
  constexpr auto expect = [](bool cond) { if (not cond) { void failed(); failed(); } };

  // jmp::utility::array
  {
    {
      jmp::utility::array<int, 1> a{};
      expect(1u == a.size());
      expect(0 == a[0]);
    }
    {
      jmp::utility::array a{1, 2, 3};
      expect(3u == a.size());
      expect(1 == a[0]);
      expect(2 == a[1]);
      expect(3 == a[2]);
    }
  }

  // jmp::static_branch
  {
    static_assert(1u == sizeof(jmp::static_branch));
    static_assert(not [](auto... ts) { return requires { jmp::static_branch{ts...}; }; }());
    static_assert(not [](auto... ts) { return requires { jmp::static_branch{ts...}; }; }(jmp::static_branch{false}));
    static_assert([](auto direction) { return requires { jmp::static_branch{direction}; }; }(false));
  }
}(), true));
#endif // NTEST
#endif // $JMP
#endif // README
