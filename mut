// <!--
//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifdef README
// -->
[![Boost Licence](http://img.shields.io/badge/license-boost-blue.svg)](http://www.boost.org/LICENSE_1_0.txt)
[![Version](https://badge.fury.io/gh/boost-ext%2Fmut.svg)](https://github.com/boost-ext/mut/releases)
[![build](https://img.shields.io/badge/build-blue.svg)](https://godbolt.org/z/ohMbaMY9c)
[![Try it online](https://img.shields.io/badge/try%20it-online-blue.svg)](https://godbolt.org/z/hn3EYn9r5)

---------------------------------------

## Mut: Mutable branching library

> https://en.wikipedia.org/wiki/Branch_(computer_science)

### Use cases

> When performance matters
  - `and` branches are known at compile-time
  - `or` branches are not changing often at run-time
      - `and/or` branches are expensive to compute/require memory access
      - `and/or` branches are hard to learn by the hardware branch predictor due to their random nature

> Examples: logging, tracing, configuration, algo, ...

### Features

- Single header (https://raw.githubusercontent.com/boost-ext/mut/main/mut - for integration see [FAQ](#faq))
- Minimal [API](#api)
- Verifies itself upon include (can be disabled with `-DNTEST` - see [FAQ](#faq))

### Requirements

- C++20 ([clang++15+, g++11+](https://en.cppreference.com/w/cpp/compiler_support)) / [x86-64](https://en.wikipedia.org/wiki/X86-64) / [Linux](https://en.wikipedia.org/wiki/Linux)

---

### Overview

> `static_bool` (https://godbolt.org/z/hn3EYn9r5)

```cpp
/**
 * constexpr minimal overhead static bool changed at run-time via code patching
 */
constexpr mut::static_bool semi_runtime_branch = false;

/**
 * Note: `fun` can be inline/noinline/constexpr/etc.
 * constexpr void fun();
 * inline void fun();
 * [[gnu::noinline]] void fun()
 * [[gnu::always_inline]] void fun()
 */
void fun() {
  if (semi_runtime_branch) {
    std::puts("taken");
  } else {
    std::puts("not taken");
  }
}

int main() {
  fun(); // not taken

  semi_runtime_branch = true;
  fun(); // taken

  semi_runtime_branch = false;
  fun(); // not taken
}
```

```cpp
main: // $CXX -O3
  lea rdi, [rip + .L.str.1]
  nop # code patching (nop->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp1:
  call puts@PLT # not taken

  call semi_runtime_branch.operator=(true)

  lea rdi, [rip + .L.str.1]
  jmp .Ltmp2 # code patching (nop->jmp)
  lea rdi, [rip + .L.str.2]
 .Ltmp2:
  call puts@PLT # taken

  call semi_runtime_branch.operator=(false)

  lea rdi, [rip + .L.str.1]
  nop # code patching (jmp->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp3:
  call puts@PLT # not taken

  xor  eax, eax # return 0
  ret

.L.str.1: .asciz "taken"
.L.str.2: .asciz "not taken"
```

> `unsafe` (https://godbolt.org/z/E3j5o3j7P)

```cpp
constexpr mut::static_bool semi_runtime_branch = false;

[[gnu::noinline]] void fun() { // noinlnie is required to use unsafe!
  if (semi_runtime_branch) {
    std::puts("taken");
  } else {
    std::puts("not taken");
  }
}

int main() {
  semi_runtime_branch = mut::unsafe{true};
  fun(); // taken
}
```

```sh
fun():
  lea rdi, [rip + .L.str.1]
  nop # code patching (nop->jmp)
  lea rdi, [rip + .L.str.2]
  jmp  puts@PLT

main:
  # semi_runtime_branch = true
  push  rax
  mov   rax, qword ptr [rip + __start___mut@GOTPCREL]
  mov   rax, qword ptr [rax + 8]
  movzx ecx, byte ptr [rip + ops+9]
  mov   byte ptr [rax + 4], cl
  mov   ecx, dword ptr [rip + ps+5]
  mov   dword ptr [rax], ecx

  # fun()
  call  fun() # taken
  xor   eax, eax
  pop   rcx
  ret
```

---

### API

```cpp
/**
 * [unsafe] Only changes single entry (assumes all calls are inlined)
 */
struct unsafe final {
  bool direction{};
  constexpr operator bool() const { return direction; }
};
```

```cpp
/**
 * Minimal overhead static bool
 * @return true (always)
 */
template<auto Id = +[]{}>
struct static_bool final {
  constexpr explicit(false) static_bool(const bool) noexcept;

  /**
   * Updates branch direction
   * Note: Assumes branch might be inlined
   * @param direction new branch direction
   */
  constexpr void operator=(const bool direction) const noexcept;

  /**
   * Updates branch direction (unsafe)
   * Note: Assumes the branch is not inlined
   * @param direction new branch direction
   */
  constexpr void operator=(const unsafe direction) const noexcept;

  /**
   * Returns branch direction
   * @return current branch direction
   */
  [[gnu::always_inline]] [[nodiscard]] constexpr operator bool() const noexcept;
};
```

> Configuration

```cpp
#define MUT 2'0'0 // Current library version (SemVer)
```

---

### FAQ

- How does it work?

  > `mut` is using technique called code patching - which basically means that the code modifies itself.

  `static_bool` is based on https://docs.kernel.org/staging/static-keys.html and it requires `asm goto` support (gcc, clang).
  `mut` currently supports x86-64 Linux, but other platforms can be added using the same technique.

  Example:

    ```cpp
    constexpr mut::static_bool b = false;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      .byte 15 31 68 0 0 # nop - https://www.felixcloutier.com/x86/nop
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

  which will effectively execute...

    ```cpp
    main:
      nop
      xor eax, eax # return 0
      ret
    ```

  now, if we change the branch direction at run-time...

    ```cpp
    b = true;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      call b.operator=(true); # nop->jmp or jmp->nop

      jmp .LBB1: (nop->jmp - changed in the memory of the program)
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

- How to integrate with CMake/CPM?

    ```
    CPMAddPackage(
      Name mut
      GITHUB_REPOSITORY boost-ext/mut
      GIT_TAG v2.0.0
    )
    add_library(mp INTERFACE)
    target_include_directories(mp SYSTEM INTERFACE ${mp_SOURCE_DIR})
    add_library(mut::mut ALIAS mut)
    ```

    ```
    target_link_libraries(${PROJECT_NAME} mut:mut)
    ```

- Acknowledgments

  > https://docs.kernel.org/staging/static-keys.html, https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html, https://www.agner.org/optimize/instruction_tables.pdf, https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html, https://www.felixcloutier.com/documents/gcc-asm.html, https://www.felixcloutier.com/x86, https://uops.info/table.html, https://arxiv.org/abs/2308.14185, https://arxiv.org/pdf/2011.13127

<!--
#else
#ifndef MUT
#define MUT 2'0'0 // SemVer
#pragma GCC system_header

#include <array>      // std::array
#include <unistd.h>   // PAGESIZE
#include <sys/mman.h> // mprotect

#ifndef MUT_SIZE
#define MUT_SIZE 1024
#endif

namespace mut::inline v2_0_0 {
using u8  = __UINT8_TYPE__;
using u16 = __UINT16_TYPE__;
using u32 = __UINT32_TYPE__;
using u64 = __UINT64_TYPE__;

namespace utility {
template<class T, u32 N>
struct static_vector {
  constexpr static_vector() = default;
  constexpr auto push_back(const T& value) { values_[size_++] = value; }
  [[nodiscard]] constexpr const auto& operator[](auto i) const { return values_[i]; }
  [[nodiscard]] constexpr auto begin() const { return &values_[0]; }
  [[nodiscard]] constexpr auto end() const { return &values_[0] + size_; }
  [[nodiscard]] constexpr auto size() const { return size_; }
  [[nodiscard]] constexpr auto empty() const { return not size_; }
  [[nodiscard]] constexpr auto capacity() const { return N; }
  std::array<T, N> values_{};
  u32 size_{};
};
} // namespace utility

namespace detail {
struct entry {
  void* self{};   /// identifier
  void* memory{}; /// code memory (to be patched)
  u64 offset{};   /// jmp offset
};
extern "C" entry __start___mut [[gnu::section("__mut")]];
extern "C" entry __stop___mut [[gnu::section("__mut")]];
} // detail

/**
 * [unsafe] Only changes a single entry
 */
struct unsafe final { bool direction{}; };

inline namespace x86 {
/**
 * Minimal overhead static bool
 */
class static_bool final {
  using uop_t = std::array<u8, 5u>;
  static constexpr uop_t NOP{0x0f, 0x1f, 0x44, 0x00, 0x00}; /// https://www.felixcloutier.com/x86/nop
  struct [[gnu::packed]] JMP{ u8 op{0xe9}; u32 offset; };   /// https://www.felixcloutier.com/x86/jmp
  static_assert(sizeof(NOP) == sizeof(JMP));

 public:
  constexpr static_bool() noexcept = default;
  constexpr static_bool(const static_bool&) noexcept = delete;
  constexpr static_bool(static_bool&&) noexcept = delete;
  constexpr auto operator=(const static_bool&) noexcept = delete;
  constexpr auto operator=(static_bool&&) noexcept = delete;

  [[gnu::noinline]] static void init() {
    const auto page_size = sysconf(_SC_PAGESIZE);
    const auto start = &detail::__start___mut;
    const auto stop = &detail::__stop___mut;
    const auto size = stop - start;
    for (auto i = 0u; i < size; ++i) {
      const auto& entry = start[i];
      mprotect(reinterpret_cast<void*>((u64)entry.memory & ~(page_size - 1u)),
               uop_t{}.size(), PROT_READ | PROT_WRITE | PROT_EXEC);
      const JMP jmp{.offset = static_cast<u32>(entry.offset)};
      static_cast<static_bool*>(entry.self)->entries_.push_back({
        static_cast<uop_t*>(entry.memory),
        {NOP, uop_t{*reinterpret_cast<const uop_t*>(&jmp)}}
      });
    }
  }

  /**
   * Updates branch direction
   * Note: Assumes possibly many inlined versions of the branch
   * @param direction new branch direction
   */
  constexpr void operator=(const bool direction) const noexcept {
    for (const auto& entry : entries_) entry(direction);
  }

  /**
   * Updates branch direction (unsafe)
   * Note: Assumes single - no inlined - version of the branch
   * @param direction new branch direction
   */
  constexpr void operator=(const unsafe direction) const noexcept {
    entries_[0](direction.direction);
  }

  /**
   * Returns branch direction
   * @return current branch direction
   */
  [[gnu::always_inline]] [[nodiscard]] inline operator bool() const noexcept {
    asm volatile goto("0:"
      ".byte %c3, %c4, %c5, %c6, %c7 \n"
      ".pushsection __mut, \"aw\" \n"
      ".balign %c0 \n"
      ".quad %c1, 0b, %l[true_] - (0b + %c2) \n"
      ".popsection \n"
      : : "i"(alignof(u64)),
          "i"(this),
          "i"(uop_t{}.size()),
          "i"(NOP[0]), "i"(NOP[1]), "i"(NOP[2]), "i"(NOP[3]), "i"(NOP[4])
      : : true_);
    false_: return false;
    true_:  return true;
  }

 private:
  struct entry {
    uop_t* memory{};
    std::array<uop_t, 2u> ops{};
    constexpr void operator()(const bool direction) const noexcept {
      *memory = ops[direction];
    }
  };
  utility::static_vector<entry, MUT_SIZE> entries_{};
};
} // namespace x86
} // namespace mut

#ifndef NTEST
static_assert(([] {
  // mut::utility::static_vector
  {
  }

  // mut::unsafe
  {
    static_assert(not mut::unsafe{false}.direction);
    static_assert(mut::unsafe{true}.direction);
  }

  // mut::static_bool
  {
    //static_assert(mut::static_bool{false} != mut::static_bool{false});
    //constexpr mut::static_bool a = false;
    //constexpr mut::static_bool b = false;
    //static_assert(a == a);
    //static_assert(a != b);
  }
}(), true));
#endif // NTEST
#endif // MUT
#endif // README
