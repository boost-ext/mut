// <!--
//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifdef README
// -->
[![Boost Licence](http://img.shields.io/badge/license-boost-blue.svg)](http://www.boost.org/LICENSE_1_0.txt)
[![Version](https://badge.fury.io/gh/boost-ext%2Fmut.svg)](https://github.com/boost-ext/mut/releases)
[![build](https://img.shields.io/badge/build-blue.svg)](https://godbolt.org/z/ohMbaMY9c)
[![Try it online](https://img.shields.io/badge/try%20it-online-blue.svg)](https://godbolt.org/z/hn3EYn9r5)

---------------------------------------

## Mut: Mutable branching library

> https://en.wikipedia.org/wiki/Branch_(computer_science)

### Use cases

> When performance matters
  - `and` branches are known at compile-time
  - `or` branches are not changing often at run-time
      - `and/or` branches are expensive to compute/require memory access
      - `and/or` branches are hard to learn by the hardware branch predictor due to their random nature

> Examples: logging, tracing, configuration, algo, ...

### Features

- Single header (https://raw.githubusercontent.com/boost-ext/mut/main/mut - for integration see [FAQ](#faq))
- Minimal [API](#api)
- Verifies itself upon include (can be disabled with `-DNTEST` - see [FAQ](#faq))

### Requirements

- C++20 ([clang++15+, g++11+](https://en.cppreference.com/w/cpp/compiler_support)) / [x86-64](https://en.wikipedia.org/wiki/X86-64) / [Linux](https://en.wikipedia.org/wiki/Linux)

---

### Overview

> `static_bool` (https://godbolt.org/z/hn3EYn9r5)

```cpp
/**
 * constexpr minimal overhead static bool changed at run-time via code patching
 */
constexpr mut::static_bool semi_runtime_branch = false;

/**
 * Note: `fun` can be inline/noinline/constexpr/etc.
 * constexpr void fun();
 * inline void fun();
 * [[gnu::noinline]] void fun()
 * [[gnu::always_inline]] void fun()
 */
void fun() {
  if (semi_runtime_branch) {
    std::puts("taken");
  } else {
    std::puts("not taken");
  }
}

int main() {
  fun(); // not taken

  semi_runtime_branch = true;
  fun(); // taken

  semi_runtime_branch = false;
  fun(); // not taken
}
```

```cpp
main: // $CXX -O3
  lea rdi, [rip + .L.str.1]
  nop # code patching (nop->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp1:
  call puts@PLT # not taken

  call semi_runtime_branch.operator=(true)

  lea rdi, [rip + .L.str.1]
  jmp .Ltmp2 # code patching (nop->jmp)
  lea rdi, [rip + .L.str.2]
 .Ltmp2:
  call puts@PLT # taken

  call semi_runtime_branch.operator=(false)

  lea rdi, [rip + .L.str.1]
  nop # code patching (jmp->nop)
  lea rdi, [rip + .L.str.2]
 .Ltmp3:
  call puts@PLT # not taken

  xor  eax, eax # return 0
  ret

.L.str.1: .asciz "taken"
.L.str.2: .asciz "not taken"
```

---

### API

```cpp
class static_bool final {
 public:
  template<auto Id = +[]{}>
  constexpr static_bool(const bool direction) noexcept;
  constexpr static_bool(const static_bool&) noexcept = delete;
  constexpr static_bool(static_bool&&) noexcept = delete;
  constexpr auto operator=(const static_bool&) noexcept = delete;
  constexpr auto operator=(static_bool&&) noexcept = delete;

  /**
   * Updates branch direction
   * @param direction new branch direction
   */
  void operator=(const bool direction) const noexcept;

  /**
   * Returns branch direction
   * @return current branch direction
   */
  [[gnu::always_inline]] [[nodiscard]] inline operator bool() const noexcept;
};
```

> Configuration

```cpp
#define MUT 2'0'0 // Current library version (SemVer)
```

---

### FAQ

- How does it work?

  > `mut` is using technique called code patching - which basically means that the code modifies itself.

  `mut::static_bool` is based on https://docs.kernel.org/staging/static-keys.html and it requires `asm goto` support (gcc, clang).
  `mut` currently supports x86-64 Linux, but other platforms can be added using the same technique.

  Example:

    ```cpp
    constexpr mut::static_bool b = false;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      .byte 15 31 68 0 0 # nop - https://www.felixcloutier.com/x86/nop
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

  which will effectively execute...

    ```cpp
    main:
      nop
      xor eax, eax # return 0
      ret
    ```

  now, if we change the branch direction at run-time...

    ```cpp
    b = true;

    if (b) {
      return 42;
    } else {
      return 0;
    }
    ```

  it will emit...

    ```cpp
    main:
      call b.operator=(true); # nop->jmp or jmp->nop

      jmp .LBB1: (nop->jmp - changed in the memory of the program)
      xor eax, eax # return 0
      ret
    .LBB1:
      mov eax, 42 # return 42
      ret
    ```

- How to integrate with CMake/CPM?

    ```
    CPMAddPackage(
      Name mut
      GITHUB_REPOSITORY boost-ext/mut
      GIT_TAG v2.0.0
    )
    add_library(mp INTERFACE)
    target_include_directories(mp SYSTEM INTERFACE ${mp_SOURCE_DIR})
    add_library(mut::mut ALIAS mut)
    ```

    ```
    target_link_libraries(${PROJECT_NAME} mut:mut)
    ```

- Acknowledgments

  > https://docs.kernel.org/staging/static-keys.html, https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html, https://www.agner.org/optimize/instruction_tables.pdf, https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html, https://www.felixcloutier.com/documents/gcc-asm.html, https://www.felixcloutier.com/x86, https://uops.info/table.html, https://arxiv.org/abs/2308.14185, https://arxiv.org/pdf/2011.13127

<!--
#else
#ifndef MUT
#define MUT 2'0'0 // SemVer
#pragma GCC system_header

#include <array>      // std::array
#include <cassert>    // assert
#include <unistd.h>   // PAGESIZE
#include <sys/mman.h> // mprotect

namespace mut::inline v2_0_0 {
using u8  = __UINT8_TYPE__;
using u16 = __UINT16_TYPE__;
using u32 = __UINT32_TYPE__;
using u64 = __UINT64_TYPE__;

namespace detail {
struct entry {
  void (*id)(){}; /// identifier
  void* memory{}; /// code memory (to be patched)
  u64 offset{};   /// jmp offset
};
extern "C" entry __start___mut [[gnu::section("__mut")]];
extern "C" entry __stop___mut [[gnu::section("__mut")]];
} // detail

inline namespace x86 {
/**
 * Minimal overhead static bool
 */
class static_bool final {
  using uop_t = std::array<u8, 5u>;
  static constexpr uop_t NOP{0x0f, 0x1f, 0x44, 0x00, 0x00}; /// https://www.felixcloutier.com/x86/nop
  struct [[gnu::packed]] JMP{ u8 op{0xe9}; u32 offset; };   /// https://www.felixcloutier.com/x86/jmp
  static_assert(sizeof(NOP) == sizeof(JMP));

 public:
  template<auto Id = +[]{}>
  constexpr static_bool(const bool direction) noexcept : id_{Id} {
    void failed(); if (direction) failed(); /// direction should be false for performance: { false: nop, true: unconditional jmp }
  }
  constexpr static_bool(const static_bool&) noexcept = delete;
  constexpr static_bool(static_bool&&) noexcept = delete;
  constexpr auto operator=(const static_bool&) noexcept = delete;
  constexpr auto operator=(static_bool&&) noexcept = delete;

  static const inline auto init = ([] {
    constexpr auto permissions = PROT_READ | PROT_WRITE | PROT_EXEC;
    const auto page_size = sysconf(_SC_PAGESIZE);
    for (auto entry = &detail::__start___mut; entry != &detail::__stop___mut; ++entry) {
      const auto result = mprotect(reinterpret_cast<void*>((u64)entry->memory & ~(page_size - 1u)), sizeof(uop_t), permissions);
      assert(not result);
    }
  }(), nullptr);

  /**
   * Updates branch direction
   * @param direction new branch direction
   */
  void operator=(const bool direction) const noexcept {
    JMP jmp{};
    const std::array<const uop_t*, 2u> ops{&NOP, reinterpret_cast<const uop_t*>(&jmp)};
    for (auto entry = &detail::__start___mut; entry != &detail::__stop___mut; ++entry) {
      if (entry->id != id_) continue;
      jmp.offset = static_cast<u32>(entry->offset);
      *static_cast<uop_t*>(entry->memory) = *ops[direction];
    }
  }

  /**
   * Returns branch direction
   * @return current branch direction
   */
  [[gnu::always_inline]] [[nodiscard]] inline operator bool() const noexcept {
    asm volatile goto("0:"
      ".byte %c3, %c4, %c5, %c6, %c7 \n"
      ".pushsection __mut, \"aw\" \n"
      ".balign %c0 \n"
      ".quad %c1, 0b, %l[true_] - (0b + %c2) \n"
      ".popsection \n"
      : : "i"(alignof(u64)),
          "i"(id_),
          "i"(sizeof(uop_t)),
          "i"(NOP[0]), "i"(NOP[1]), "i"(NOP[2]), "i"(NOP[3]), "i"(NOP[4])
      : : true_);
    false_: return false;
    true_:  return true;
  }

 private:
  void (*id_)(){};
};
} // namespace x86
} // namespace mut

#ifndef NTEST
static_assert(([] {

  // mut::static_bool
  {
    //static_assert(mut::static_bool{false} != mut::static_bool{false});
    //constexpr mut::static_bool a = false;
    //constexpr mut::static_bool b = false;
    //static_assert(a == a);
    //static_assert(a != b);
  }
}(), true));
#endif // NTEST
#endif // MUT
#endif // README
